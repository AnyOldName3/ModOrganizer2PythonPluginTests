import codecs
import sys

from PyQt5.QtCore import QCoreApplication, QDateTime, QDir, QFileInfo
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QMessageBox

if "mobase" not in sys.modules:
    import mock_mobase as mobase

class AGameGamePlugins(mobase.GamePlugins):
    def __init__(self, organizer):
        #QMessageBox.information(None, "__init__", "__init__gp")
        super(AGameGamePlugins, self).__init__()
        self.__organizer = organizer
        self.__lastRead = None
    
    def writePluginLists(self, pluginList):
        #QMessageBox.information(None, "writePluginLists", "writePluginLists")
        if self.__lastRead == None:
            return
        with open(os.path.join(self.__organizer.profile().absolutePath(), "plugins.txt"), 'w') as pf:
            with codecs.open(os.path.join(self.__organizer.profile().absolutePath(), "loadorder.txt"), 'w', "utf-8") as lof:
                pf.write("# This file was automatically generated by Mod Organizer, but in Python!\n")
                lof.write("# This file was automatically generated by Mod Organizer, but in Python!\n")
                sortedList = pluginList.pluginNames()
                sortedList.sort(key=lambda x: pluginList.priority(x))
                for pluginName in sortedList:
                    if pluginList.state(pluginName) == 2:
                        pf.write(pluginName)
                        pf.write("\n")
                    lof.write(pluginName)
                    lof.write("\n")
        self.__lastRead = QDateTime.currentDateTime()
    
    def readPluginLists(self, pluginList):
        #QMessageBox.information(None, "readPluginLists", "readPluginLists")
        pluginsPath = os.path.join(self.__organizer.profile().absolutePath(), "plugins.txt")
        loadorderPath = os.path.join(self.__organizer.profile().absolutePath(), "loadorder.txt")
        
        loadOrderIsNew = self.__lastRead == None or not QFileInfo(loadorderPath).exists() or QFileInfo(loadorderPath).lastModified() > self.__lastRead
        pluginsIsNew = self.__lastRead == None or QFileInfo(pluginsPath).lastModified() > self.__lastRead
        
        if loadOrderIsNew or not pluginsIsNew:
            self.__readLoadOrderList(pluginList, loadorderPath)
            self.__readPluginList(pluginList, False)
        else:
            self.__readPluginList(pluginList, True)
        
        self.__lastRead = QDateTime.currentDateTime()
    
    def __readLoadOrderList(self, pluginList, filePath):
        #QMessageBox.information(None, "__readLoadOrderList", "__readLoadOrderList")
        try:
            with codecs.open(filePath, "r", "utf-8-sig") as file:
                plugins = self.__organizer.managedGame().primaryPlugins()
                plugins = [item.decode("utf-8") for item in plugins]
                file.seek(0, os.SEEK_END)
                if file.tell() == 0:
                    self.__readPluginList(pluginList, True)
                    return True
                file.seek(0, os.SEEK_SET)
                for line in file:
                    line = line.strip()
                    if line[0] == u"#" or len(line) == 0:
                        continue
                    if not line.upper() in map(unicode.upper, plugins):
                        plugins.append(line)
                pluginList.setLoadOrder(plugins)
        except IOError:
            self.__readPluginList(pluginList, True)
        
        return True
    
    def __readPluginList(self, pluginList, useLoadOrder):
        #QMessageBox.information(None, "__readPluginList", "__readPluginList")
        primary = self.__organizer.managedGame().primaryPlugins()
        for pluginName in primary:
            if pluginList.state(pluginName) != 0:
                pluginList.setState(pluginName, 2)
        
        plugins = pluginList.pluginNames()
        # note: list might not be necessary as even though QStringLists are shared, PyQt5 doesn't do that
        pluginsClone = list(plugins)
        for plugin in pluginsClone:
            if plugin.upper() in map(str.upper, primary):
                plugins[:] = (value for value in plugins if value.upper() != plugin.upper())
        
        def pluginToQDateTime(plugin):
            lhm = self.__organizer.getMod(pluginList.origin(plugin))
            lhd = self.__organizer.managedGame().dataDirectory()
            if lhm != None:
                lhd = QDir(lhm.absolutePath())
            lhp = lhd.absoluteFilePath(plugin)
            return QFileInfo(lhp).lastModified()
        
        plugins.sort(key=pluginToQDateTime)
        
        pluginsTxtExists = True
        filePath = os.path.join(self.__organizer.profile().absolutePath(), "plugins.txt")
        try:
            with open(filePath, 'r') as file:
                file.seek(0, os.SEEK_END)
                if file.tell() == 0:
                    pluginsTxtExists = False
                file.seek(0, os.SEEK_SET)
                
                activePlugins = []
                inactivePlugins = []
                if pluginsTxtExists:
                    for line in file:
                        line = line.strip()
                        if len(line) == 0 or line[0] == "#":
                            continue
                        pluginList.setState(line, 2)
                        activePlugins.append(line)
                    
                    for pluginName in plugins:
                        if pluginName not in activePlugins:
                            inactivePlugins.append(pluginName)
                    
                    for pluginName in inactivePlugins:
                        pluginList.setState(pluginName, 1)
                else:
                    for pluginName in plugins:
                       pluginList.setState(pluginName, 1) 
        except IOError:
            pluginsTxtExists - False
        
        if useLoadOrder:
            pluginList.setLoadOrder(primary + plugins)
        
        return True

class AGame(mobase.IPluginGame):
    
    def __init__(self):
        #QMessageBox.information(None, "__init__", "__init__")
        super(AGame, self).__init__()
        self.__featureMap = {}

    def init(self, organizer):
        #QMessageBox.information(None, "init", "init")
        self.__featureMap[mobase.GamePlugins] = AGameGamePlugins(organizer)
        return True

    def name(self):
        #QMessageBox.information(None, "name", "name")
        return "Fake Game Support Plugin"

    def author(self):
        QMessageBox.information(None, "author", "author")
        return "AnyOldName3"

    def description(self):
        QMessageBox.information(None, "description", "description")
        return self.__tr("Adds support for a fake game from within Python to see if it is even possible.")

    def version(self):
        QMessageBox.information(None, "version", "version")
        return mobase.VersionInfo(0, 1, 0, mobase.ReleaseType.prealpha)

    def isActive(self):
        QMessageBox.information(None, "isActive", "isActive")
        return True

    def settings(self):
        #QMessageBox.information(None, "settings", "settings")
        return []
    
    def gameName(self):
        #QMessageBox.information(None, "gameName", "gameName")
        return "A Fake Game"

    def executables(self):
        #QMessageBox.information(None, "executables", "executables")
        return [mobase.ExecutableInfo("A Fake Game", QFileInfo("C:/Games/Fake Game/fakegame.exe"))]
    
    def initializeProfile(self, path, settings):
        #QMessageBox.information(None, "Initialising Profile", "Initialising profile in " + path.path())
        pass
    
    def savegameExtension(self):
        #QMessageBox.information(None, "savegameExtension", "savegameExtension")
        return "sav"
    
    def savegameSEExtension(self):
        QMessageBox.information(None, "savegameSEExtension", "savegameSEExtension")
        return "sesav"
    
    def steamAPPId(self):
        #QMessageBox.information(None, "steamAPPId", "steamAPPId")
        return "" # we're not on Steam yet :'(
    
    def primaryPlugins(self):
        #QMessageBox.information(None, "primaryPlugins", "primaryPlugins")
        return ["afakegame.master", "update.plugin"]
    
    def gameVariants(self):
        QMessageBox.information(None, "gameVariants", "gameVariants")
        return ["Regular", "Enhanced"]
    
    def gameShortName(self):
        #QMessageBox.information(None, "gameShortName", "gameShortName")
        return "AFakeGame"
    
    def validShortNames(self):
        return [self.gameShortName(), "Fakier2TheFakerFake"]
    
    def gameNexusName(self):
        QMessageBox.information(None, "gameNexusName", "gameNexusName")
        return "AFakeGame"
    
    def iniFiles(self):
        #QMessageBox.information(None, "iniFiles", "iniFiles")
        return ["fakegame.cfg", "user.cfg"]
    
    def DLCPlugins(self):
        QMessageBox.information(None, "DLCPlugins", "DLCPlugins")
        return []
    
    def CCPlugins(self):
        QMessageBox.information(None, "CCPlugins", "CCPlugins")
        return []
    
    def loadOrderMechanism(self):
        #QMessageBox.information(None, "loadOrderMechanism", "loadOrderMechanism")
        return mobase.LoadOrderMechanism.PluginsTxt
    
    def sortMechanism(self):
        #QMessageBox.information(None, "sortMechanism", "sortMechanism")
        return mobase.SortMechanism.NONE
    
    def nexusModOrganizerID(self):
        QMessageBox.information(None, "nexusModOrganizerID", "nexusModOrganizerID")
        return 0
    
    def nexusGameID(self):
        QMessageBox.information(None, "nexusGameID", "nexusGameID")
        return 9999
    
    def isInstalled(self):
        #QMessageBox.information(None, "isInstalled", "isInstalled")
        return True
    
    def gameIcon(self):
        #QMessageBox.information(None, "gameIcon", "gameIcon")
        return QIcon("C:/Games/Fake Game/fakegame.ico")
    
    def gameDirectory(self):
        #QMessageBox.information(None, "gameDirectory", "gameDirectory")
        return QDir("C:/Games/Fake Game")
    
    def dataDirectory(self):
        #QMessageBox.information(None, "dataDirectory", "dataDirectory")
        return QDir("C:/Games/Fake Game/data")
    
    def setGamePath(self, pathStr):
        #QMessageBox.information(None, "Changing game path", "Changing game path to " + pathStr)
        pass
    
    def documentsDirectory(self):
        #QMessageBox.information(None, "documentsDirectory", "documentsDirectory")
        return self.gameDirectory()
    
    def savesDirectory(self):
        QMessageBox.information(None, "savesDirectory", "savesDirectory")
        return self.documentsDirectory()
    
    def setGameVariant(self, variantStr):
        #QMessageBox.information(None, "Setting variant", "Setting variant to " + variantStr)
        pass
    
    def binaryName(self):
        QMessageBox.information(None, "binaryName", "binaryName")
        return "fakegame.exe"
    
    def looksValid(self, aQDir):
        #QMessageBox.information(None, "looksValid", "looksValid")
        return True
    
    def gameVersion(self):
        QMessageBox.information(None, "gameVersion", "gameVersion")
        return "1"
    
    def getLauncherName(self):
        QMessageBox.information(None, "getLauncherName", "getLauncherName")
        return "fakegamelauncher.exe"
    
    def _featureList(self):
        return self.__featureMap
    
    def __tr(self, str):
        return QCoreApplication.translate("AGame", str)
    
def createPlugin():
    return AGame()